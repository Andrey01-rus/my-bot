from flask import Flask
from threading import Thread
import json
import random
import requests
import os
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters
)

# --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Flask ---
app = Flask(__name__)

@app.route('/')
def home():
    return "ü§ñ –ë–æ—Ç –∞–∫—Ç–∏–≤–µ–Ω!"

# --- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ---
AI_CHAT = 1
REDDIT_SUBREDDITS = ["memes", "dankmemes", "Pikabu"]
MEME_CACHE = {
    "memes": [],
    "last_update": None
}

# --- –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö ---
with open('ideas.json', 'r', encoding='utf-8') as f:
    ideas = json.load(f)

# --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–æ—Ç–∞ ---
TOKEN = os.getenv("TELEGRAM_TOKEN")
OPENROUTER_KEY = os.getenv("OPENROUTER_KEY")
MODEL = "nvidia/llama-3.3-nemotron-super-49b-v1:free"

# --- –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---
def main_keyboard():
    buttons = [
        [InlineKeyboardButton("üé≤ –ò–¥–µ—è", callback_data='idea'),
         InlineKeyboardButton("üìç –ú–µ—Å—Ç–æ", callback_data='place')],
        [InlineKeyboardButton("üïπ –ò–≥—Ä–∞", callback_data='game'),
         InlineKeyboardButton("ü§ñ –ò–ò-—á–∞—Ç", callback_data='ai_chat')],
        [InlineKeyboardButton("üñº –°–ª—É—á–∞–π–Ω—ã–π –º–µ–º", callback_data='get_meme')]
    ]
    return InlineKeyboardMarkup(buttons)

def ai_chat_keyboard():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ùå –í—ã–π—Ç–∏ –∏–∑ –ò–ò-—á–∞—Ç–∞", callback_data='exit_ai')]
    ])

def meme_keyboard():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üé≤ –ï—â—ë –º–µ–º", callback_data='more_memes')],
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data='back')]
    ])

# --- –§—É–Ω–∫—Ü–∏–∏ –º–µ–º–æ–≤ ---
async def fetch_reddit_memes():
    """–ü–æ–ª—É—á–∞–µ–º —Å–≤–µ–∂–∏–µ –º–µ–º—ã —Å Reddit"""
    global MEME_CACHE
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–µ—à (–æ–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–∑ –≤ 2 —á–∞—Å–∞)
    if MEME_CACHE["last_update"] and (datetime.now() - MEME_CACHE["last_update"]).seconds < 7200:
        return MEME_CACHE["memes"]
    
    new_memes = []
    for subreddit in REDDIT_SUBREDDITS:
        try:
            url = f"https://www.reddit.com/r/{subreddit}/top.json?limit=10&t=day"
            headers = {"User-Agent": "MemeBot/1.0"}
            response = requests.get(url, headers=headers, timeout=15)
            
            for post in response.json().get("data", {}).get("children", []):
                if post["data"].get("post_hint") == "image":
                    new_memes.append({
                        "url": post["data"]["url"],
                        "source": f"https://reddit.com{post['data']['permalink']}",
                        "title": post["data"]["title"]
                    })
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ r/{subreddit}: {e}")
    
    MEME_CACHE = {
        "memes": new_memes[:50],  # –°–æ—Ö—Ä–∞–Ω—è–µ–º 50 —Å–≤–µ–∂–∏—Ö –º–µ–º–æ–≤
        "last_update": datetime.now()
    }
    return MEME_CACHE["memes"]

async def send_random_meme(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –º–µ–º"""
    query = update.callback_query
    await query.answer()
    
    try:
        memes = await fetch_reddit_memes()
        if not memes:
            await query.edit_message_text("üòî –ú–µ–º—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ!", 
                                      reply_markup=main_keyboard())
            return
        
        meme = random.choice(memes)
        await context.bot.send_photo(
            chat_id=query.message.chat_id,
            photo=meme["url"],
            caption=f"<b>{meme['title']}</b>\n\n–ò—Å—Ç–æ—á–Ω–∏–∫: {meme['source']}",
            reply_markup=meme_keyboard(),
            parse_mode="HTML"
        )
        await query.message.delete()
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –º–µ–º–∞: {e}")
        await query.edit_message_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ–º–æ–≤", 
                                    reply_markup=main_keyboard())

# --- –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–æ—Ç–∞ ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üöÄ –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏:\n"
        "- –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∏–¥–µ–π\n- –ü–æ–∏—Å–∫ –º–µ—Å—Ç\n- –ò–≥—Ä—ã\n"
        "- –ò–ò-—á–∞—Ç\n- –°–≤–µ–∂–∏–µ –º–µ–º—ã —Å Reddit",
        reply_markup=main_keyboard()
    )
    return ConversationHandler.END

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == 'ai_chat':
        await query.edit_message_text(
            "üí¨ –†–µ–∂–∏–º –ò–ò-—á–∞—Ç–∞. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å:",
            reply_markup=ai_chat_keyboard()
        )
        return AI_CHAT

    if query.data in ['idea', 'place', 'game']:
        category_map = {
            'idea': 'activities',
            'place': 'places',
            'game': 'games'
        }
        response = random.choice(ideas[category_map[query.data]])
        await query.edit_message_text(
            text=f"üéØ {response}",
            reply_markup=main_keyboard()
        )
    
    if query.data == 'back':
        await query.edit_message_text(
            "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:",
            reply_markup=main_keyboard()
        )
    
    return ConversationHandler.END

async def ai_chat_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    answer = await ask_ai(update.message.text)
    await update.message.reply_text(
        f"ü§ñ {answer}",
        reply_markup=ai_chat_keyboard()
    )
    return AI_CHAT

async def exit_ai_chat(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "‚úÖ –í—ã –≤—ã—à–ª–∏ –∏–∑ –ò–ò-—á–∞—Ç–∞",
        reply_markup=main_keyboard()
    )
    return ConversationHandler.END

# --- –ò–ò-—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª ---
async def ask_ai(prompt):
    try:
        headers = {
            "Authorization": f"Bearer {OPENROUTER_KEY}",
            "HTTP-Referer": "https://github.com/AntiSkukaBot",
            "X-Title": "AntiSkukaBot AI"
        }
        
        response = requests.post(
            "https://openrouter.ai/api/v1/chat/completions",
            headers=headers,
            json={
                "model": MODEL,
                "messages": [{"role": "user", "content": prompt}]
            },
            timeout=20
        )
        
        return response.json()['choices'][0]['message']['content']
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ò–ò: {e}")
        return "‚ö†Ô∏è –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞"

# --- –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ---
def run_flask():
    app.run(host='0.0.0.0', port=8080)

if __name__ == '__main__':
    # –ó–∞–ø—É—Å–∫–∞–µ–º Flask –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    Thread(target=run_flask, daemon=True).start()

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
    bot_app = Application.builder().token(TOKEN).build()
    
    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    bot_app.add_handler(CommandHandler('start', start))
    
    conv_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(button_handler, pattern='^ai_chat$')],
        states={
            AI_CHAT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, ai_chat_mode),
                CallbackQueryHandler(exit_ai_chat, pattern='^exit_ai$')
            ]
        },
        fallbacks=[CommandHandler('start', start)]
    )
    
    bot_app.add_handler(conv_handler)
    bot_app.add_handler(CallbackQueryHandler(button_handler))
    bot_app.add_handler(CallbackQueryHandler(send_random_meme, pattern='^(get_meme|more_memes)$'))
    
    print("ü§ñ –ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω!")
    bot_app.run_polling(drop_pending_updates=True)
